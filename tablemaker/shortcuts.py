# tabledresser - a reddit bot that turns AMAs into tables
# Copyright (C) 2012  Yann Kaiser
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


from __future__ import print_function

import re
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO
from datetime import datetime, timedelta
from time import time
from functools import wraps
from itertools import chain

from praw import errors

from tablemaker.inputs import redditlink, cachedredditlink
from tablemaker.redditfilters import (
    QandA_grab, QandA_formatter, QandA_sort_votecount,
    QandA_splitquestions, QandA_merge,
    links_from_body, remove_tracked,
    iama_filter, verify_ama
    )
from tablemaker.markdown.writers import table
from tablemaker.redditapi import get_reddit, login, edit, submit, reddit_re
from tablemaker.outputs import linesep
from tablemaker.loop import ratelimit
from tablemaker_orm.models import (
    TrackedTable, SpecialRequest,
    REQUEST_TYPE_DELETE, REQUEST_TYPE_AUTHORS,
    )

def grab_questions(submission):
    authors = None
    for request in SpecialRequest.objects.filter(parent=submission.id):
        if request.type == REQUEST_TYPE_DELETE:
            return []
        elif request.type == REQUEST_TYPE_AUTHORS:
            authors = request.get_data()
    return QandA_grab(
        submission,
        answers_from_usernames=authors
        )

def table_questions(questions_answers):
    return table(
        ('Questions', 'Answers'), (-1, -1),
        QandA_formatter(
            QandA_splitquestions(
                QandA_sort_votecount(
                    QandA_merge(
                            questions_answers
                        )
                    )
                )
            )
        )

def make_r_iama_table(submission):
    return table_questions(grab_questions(submission))

def last_updated(tt):
    next_update = tt.get_next_update()
    return (
        '*Last updated: {:%Y-%m-%d %H:%M} UTC*'.format(tt.edited)
        + (' | *Next update: {:%Y-%m-%d %H:%M} UTC*'.format(next_update)
            if next_update else '')
        )

def post_table_comment(submission, table, tt, dry_run=False, cb=None):
    msg = StringIO()
    linesep(
        table,
        file=msg,
        limit=3000,
        intro="""\
""",
        outro="""\

""" +
    ('**[View the full table]({0})** on'.format(tt.get_submission_url('tabled')) if tt.submission
    else 'More tables at') + """ [/r/tabled](/r/tabled)! | """
    + last_updated(tt) + """

*This comment was generated by a robot! Send all complaints to [epsy](/message/compose/?to=epsy).*
"""
        )
    if dry_run:
        print('Editing comment ' + tt.comment if tt.comment else 'New comment')
        print('--- BEGIN COMMENT ---')
        print(msg.getvalue().encode('utf-8'))
        print('--- END COMMENT ---')
    else:
        if tt.comment:
            if tt.comment != '_':
                ratelimit(edit, 't1_' + tt.comment, msg.getvalue())
        else:
            def make_comment():
                try:
                    response = submission.add_comment(
                        msg.getvalue()
                        )
                except errors.APIException as e:
                    if e.error_type == 'TOO_OLD':
                        tt.comment = '_'
                        tt.save()
                    else:
                        raise
                else:
                    tt.comment = response.id
                    tt.save()
                    print("Comment link:", tt.get_comment_url(submission.subreddit.display_name))
                if cb:
                    cb()
            ratelimit(make_comment)

def submissiontitle(parent):
    title = parent.title
    subreddit = parent.subreddit.display_name
    return u"[Table] {subreddit}{title}".format(
        title=title,
        subreddit=subreddit + ': '
                  if subreddit.lower() not in title.lower().replace(' ', '')
                  else '',
        )

def post_table_submission(submission, table, tt, dry_run=False, cb=None):
    msg = StringIO()
    verified = verify_ama(submission)
    linesep(
        table,
        file=msg,
        limit=38000,
        intro="""\
**Verified?** *(This bot cannot verify AMAs just yet)*

**Date:** """ + datetime.utcfromtimestamp(submission.created_utc).strftime('%Y-%m-%d')
+ "\n\n"
+ "**[Link to submission]({0})** ".format(tt.get_parent_url(submission.subreddit.display_name))
+ (
    '(*Has self-text*)'
    if hasattr(submission, 'selftext') and submission.selftext
    else '(*No self-text*)'
  )
+ "\n\n"
+ ("**[Link to my post]({0})**\n\n".format(tt.get_comment_url(submission.subreddit.display_name)) if tt.comment else '')
+ '\n'
        ,
        outro="\n\n" + last_updated(tt) + """

*This post was generated by a robot! Send all complaints to [epsy](/message/compose/?to=epsy).*
"""
        )
    if dry_run:
        print('Editing submission ' + tt.submission if tt.submission else 'New submission')
        print('--- BEGIN SUBMISSION ---')
        print(msg.getvalue().encode('utf-8'))
        print('--- END SUBMISSION ---')
    else:
        if tt.submission:
            ratelimit(edit, 't3_' + tt.submission, msg.getvalue(), 'tabled')
            if cb:
                cb()
        else:
            def submit_to_tabled():
                link = submit(
                    submissiontitle(submission),
                    msg.getvalue(),
                    'tabled')
                tt.submission = link
                tt.save()
                print("Submission link:", tt.get_submission_url('tabled'))
                if cb:
                    cb()
            ratelimit(submit_to_tabled)

def post_ama_from_pm(url, message):
    ret, errtext = post_or_update_ama(url)
    if ret:
        print('Would tell', message.author, errtext)

MIN_AGE_TABLE = 2 * 60 * 60

def old_enough_for_table(created):
    return created < time() - MIN_AGE_TABLE

MIN_AGE_COMMENT = 4 * 60 * 60
MIN_LAST_AGE_COMMENT = 1 * 60 * 60
def old_enough_for_comment(created, last_answer):
    return (created < time() - MIN_AGE_COMMENT
        and last_answer < time() - MIN_LAST_AGE_COMMENT)

def post_or_update_ama(url, no_comment=False,
                       no_r_tabled=False, dry_run=False,
                       trust=5):
    r = get_reddit()
    if hasattr(url, 'id'):
        submission = url
    elif url.startswith('http://'):
        submission = r.get_submission(url=url)
    else:
        submission = r.get_submission(submission_id=url)

    dumbtitle = submission.title.lower().replace(' ', '')
    if (
            trust < 8
            and ('ask' not in dumbtitle or 'anything' not in dumbtitle)
            and 'ama' not in dumbtitle
            ):
        return -1, "Title does not sound like an AMA."

    if trust < 5 and old_enough_for_table(submission.created_utc):
        return -1, "As per /r/tabled rules, AMAs may only be tabled 12 hours after they started."

    qa = list(grab_questions(submission))

    table = list(table_questions(qa))

    if trust < 10 and len(table) < 15: # this ama is crap/not an ama/author deleted
        try:
            tt = TrackedTable.objects.get(parent=submission.id)
            tt.edited = datetime.utcnow()
            tt.save()
        except TrackedTable.DoesNotExist:
            pass
        return -1, "Less than 15 question/answers."

    last_answer = max(qa, key=lambda (q,a): a.created_utc)[1]
    last_answer_time = last_answer.created_utc

    try:
        tt = TrackedTable.objects.get(parent=submission.id)
        tt.edited = datetime.utcnow()
        tt.last_answer = datetime.utcfromtimestamp(last_answer_time)
    except TrackedTable.DoesNotExist:
        tt = TrackedTable(parent=submission.id)
        tt.last_answer = datetime.utcfromtimestamp(last_answer_time)
        tt.started = tt.edited = datetime.utcnow()

    print(last_answer.fullname)

    if not dry_run:
        tt.save()

    def cb():
        if not no_comment and (
                old_enough_for_comment(submission.created_utc, last_answer_time)
                or tt.comment):
            post_table_comment(submission, table, tt, dry_run)

    if not no_r_tabled:
        post_table_submission(submission, table, tt, dry_run, cb=cb)

    return 0, ""

def success(fn):
    @wraps(fn)
    def _wrapper(*args, **kwargs):
        ret = fn(*args, **kwargs)
        if ret[0]:
            print(ret[1])
        return 0
    return _wrapper

post_ama_from_loop = success(post_or_update_ama)

def mark_as_read(messages):
    for message in messages:
        message.mark_as_read()
        yield message

def new_messages():
    r = get_reddit()
    login()

    return r.user.get_unread()

def read_messages():
    r = get_reddit()
    login()
    people = {}
    for (text, address, title, autolink, host), message in links_from_body(
            mark_as_read(
                new_messages()
                )
            ):
        author = message.author.name
        linksleft = people.setdefault(author, 4)
        if linksleft:
            link = address or autolink
            m = reddit_re.match(link)
            if not m:
                continue
            subreddit, submissionid, preview, comment = m.groups()
            if not comment:
                yield "ama", link, message
            else:
                yield "verification", link, message
            people[author] = linksleft - 1

def top_iama(subreddits=('iama','internetama')):
    r = get_reddit()
    return iama_filter(
        remove_tracked(chain(
            *[
                r.get_subreddit(subreddit).get_hot(limit=25)
                for subreddit in subreddits
            ]))
        )
